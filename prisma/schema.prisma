// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "rhel-openssl-3.0.x"]
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [unaccent]
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  ADMIN
  PROFESSIONAL
}

enum AppointmentStatus {
  AGENDADO
  CONFIRMADO
  CANCELADO_ACORDADO
  CANCELADO_FALTA
  CANCELADO_PROFISSIONAL
  FINALIZADO
}

enum AppointmentModality {
  ONLINE
  PRESENCIAL
}

enum NotificationType {
  APPOINTMENT_REMINDER
  APPOINTMENT_CONFIRMATION
  APPOINTMENT_CANCELLATION
  APPOINTMENT_RESCHEDULED
  PASSWORD_RESET
  WELCOME
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

enum NotificationChannel {
  WHATSAPP
  EMAIL
}

enum ConsentType {
  TERMS_OF_SERVICE
  PRIVACY_POLICY
  DATA_PROCESSING
  MARKETING_COMMUNICATIONS
}

enum RecurrenceType {
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum RecurrenceEndType {
  BY_DATE
  BY_OCCURRENCES
  INDEFINITE
}

enum AppointmentType {
  CONSULTA
  TAREFA
  LEMBRETE
  NOTA
  REUNIAO
}

enum FeatureAccess {
  NONE
  READ
  WRITE
}

enum InvoiceStatus {
  PENDENTE
  PAGO
  CANCELADO
}

enum InvoiceItemType {
  SESSAO_REGULAR
  SESSAO_EXTRA
  SESSAO_GRUPO
  REUNIAO_ESCOLA
  CREDITO
}

enum BillingMode {
  PER_SESSION
  MONTHLY_FIXED
}

// ============================================================================
// SAAS MODELS
// ============================================================================

/// SaaS subscription plan
model Plan {
  id               String   @id @default(cuid())
  name             String
  slug             String   @unique
  stripePriceId    String   @unique
  maxProfessionals Int
  priceInCents     Int
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())

  // Relations
  clinics Clinic[]

  @@index([isActive])
}

/// Platform-level super admin (not tied to any clinic)
model SuperAdmin {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

// ============================================================================
// MODELS
// ============================================================================

/// Represents a clinic in the multi-tenant system
model Clinic {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  email     String?
  phone     String?
  address   String?
  logoUrl   String?
  timezone  String   @default("America/Sao_Paulo")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Clinic settings
  defaultSessionDuration Int    @default(50) // in minutes
  minAdvanceBooking      Int    @default(2)  // minimum hours in advance for booking
  reminderHours          Int[]  @default([24, 2]) // hours before appointment to send reminders
  invoiceMessageTemplate String? // Default invoice message template with {{variables}}
  billingMode            BillingMode @default(PER_SESSION)

  // SaaS subscription fields
  planId               String?
  plan                 Plan?    @relation(fields: [planId], references: [id])
  subscriptionStatus   String   @default("trialing")
  trialEndsAt          DateTime?
  stripeCustomerId     String?  @unique
  stripeSubscriptionId String?  @unique

  // Relations
  users                  User[]
  patients               Patient[]
  appointments           Appointment[]
  appointmentRecurrences AppointmentRecurrence[]
  notifications          Notification[]
  auditLogs              AuditLog[]
  notificationTemplates   NotificationTemplate[]
  therapyGroups           TherapyGroup[]
  groupMemberships        GroupMembership[]
  availabilityExceptions  AvailabilityException[]
  patientPhones           PatientPhone[]
  userPermissions         UserPermission[]
  invoices               Invoice[]
  sessionCredits         SessionCredit[]

  @@index([slug])
  @@index([isActive])
}

/// User account for clinic staff (admins and professionals)
model User {
  id            String    @id @default(cuid())
  clinicId      String
  email         String
  passwordHash  String
  name          String
  role          Role
  isActive      Boolean   @default(true)
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  clinic              Clinic               @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile?
  auditLogs           AuditLog[]
  permissions         UserPermission[]

  @@unique([clinicId, email])
  @@index([clinicId])
  @@index([email])
  @@index([role])
  @@index([isActive])
}

/// Extended profile for professionals (therapists, doctors, etc.)
model ProfessionalProfile {
  id                    String  @id @default(cuid())
  userId                String  @unique
  specialty             String?
  registrationNumber    String? // CRP, CRM, etc.
  bio                   String?
  appointmentDuration   Int     @default(50) // in minutes
  bufferBetweenSlots    Int     @default(10) // in minutes
  allowOnlineBooking    Boolean @default(true)
  maxAdvanceBookingDays Int     @default(30)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                       User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  availabilityRules          AvailabilityRule[]
  availabilityExceptions     AvailabilityException[]
  appointments               Appointment[]
  appointmentRecurrences     AppointmentRecurrence[]
  therapyGroups              TherapyGroup[]
  referencePatients          Patient[]                  @relation("ReferenceProfessional")
  appointmentParticipations  AppointmentProfessional[]  @relation("AppointmentParticipations")
  groupParticipations        TherapyGroupProfessional[] @relation("GroupParticipations")
  recurrenceParticipations   RecurrenceProfessional[]   @relation("RecurrenceParticipations")
  invoices               Invoice[]
  sessionCredits         SessionCredit[]

  @@index([userId])
}

/// Recurring availability rules for professionals (e.g., every Monday 9-17)
model AvailabilityRule {
  id                    String  @id @default(cuid())
  professionalProfileId String
  dayOfWeek             Int // 0 = Sunday, 6 = Saturday
  startTime             String // HH:mm format
  endTime               String // HH:mm format
  isActive              Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  professionalProfile ProfessionalProfile @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)

  @@index([professionalProfileId])
  @@index([dayOfWeek])
  @@index([isActive])
}

/// Exceptions to regular availability (vacations, specific unavailable dates, or clinic-wide holidays)
model AvailabilityException {
  id                    String    @id @default(cuid())
  professionalProfileId String?   // null for clinic-wide exceptions
  clinicId              String?   // set for clinic-wide exceptions (when professionalProfileId is null)
  date                  DateTime? @db.Date // null for recurring blocks
  dayOfWeek             Int? // 0-6 for recurring blocks (null for specific date)
  isRecurring           Boolean   @default(false)
  isAvailable           Boolean   @default(false) // false = blocked, true = extra availability
  startTime             String? // HH:mm format, null if entire day blocked
  endTime               String? // HH:mm format, null if entire day blocked
  reason                String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  professionalProfile ProfessionalProfile? @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  clinic              Clinic?              @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@index([professionalProfileId])
  @@index([clinicId])
  @@index([date])
  @@index([professionalProfileId, date])
  @@index([clinicId, date])
  @@index([professionalProfileId, isRecurring, dayOfWeek])
}

/// Patient information
model Patient {
  id          String    @id @default(cuid())
  clinicId    String
  name        String
  email       String?
  phone       String
  birthDate   DateTime? @db.Date
  cpf         String?   // Brazilian tax ID
  fatherName  String?   // Father's name
  motherName  String?   // Mother's name
  notes       String?   // Administrative observations
  schoolName  String?   // School name (for children)
  firstAppointmentDate DateTime? @db.Date // Date of first appointment (manual)
  lastFeeAdjustmentDate DateTime? @db.Date // Date of last session fee adjustment
  sessionFee  Decimal?  @db.Decimal(10, 2) // Session fee in BRL
  showAppointmentDaysOnInvoice Boolean @default(false)
  invoiceMessageTemplate       String? // Overrides clinic default for invoice text
  therapeuticProject String? // Therapeutic project (free text)
  isActive    Boolean   @default(true)
  lastVisitAt DateTime?

  // Reference professional (primary responsible)
  referenceProfessionalId String?

  // LGPD Consent fields
  consentWhatsApp   Boolean   @default(false)
  consentWhatsAppAt DateTime?
  consentEmail      Boolean   @default(false)
  consentEmailAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic                 Clinic                  @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  referenceProfessional  ProfessionalProfile?    @relation("ReferenceProfessional", fields: [referenceProfessionalId], references: [id], onDelete: SetNull)
  appointments           Appointment[]
  notifications          Notification[]
  appointmentRecurrences AppointmentRecurrence[]
  groupMemberships       GroupMembership[]
  additionalPhones       PatientPhone[]
  invoices               Invoice[]
  sessionCredits         SessionCredit[]

  @@unique([clinicId, cpf])
  @@index([clinicId])
  @@index([name])
  @@index([clinicId, phone])
  @@index([email])
  @@index([isActive])
  @@index([referenceProfessionalId])
}

/// Additional phone numbers for a patient (contacts, guardians, etc.)
model PatientPhone {
  id        String   @id @default(cuid())
  patientId String
  clinicId  String
  phone     String   // Normalized digits only, same format as Patient.phone
  label     String   // e.g., "MÃ£e", "Trabalho", "Esposo"
  notify    Boolean  @default(true) // Whether this phone receives WhatsApp notifications
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  clinic  Clinic  @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@index([clinicId, phone])
  @@index([patientId])
  @@index([clinicId])
}

/// Individual appointment or calendar entry
model Appointment {
  id                    String              @id @default(cuid())
  clinicId              String
  professionalProfileId String
  patientId             String?
  recurrenceId          String?
  groupId               String?             // Links appointments in same group session
  type                  AppointmentType     @default(CONSULTA)
  title                 String?             // Display name for non-patient entries
  blocksTime            Boolean             @default(true) // Denormalized for efficient conflict queries
  scheduledAt           DateTime
  endAt                 DateTime
  status                AppointmentStatus   @default(AGENDADO)
  modality              AppointmentModality?
  meetingUrl            String? // For online appointments
  notes                 String?
  price                 Decimal?            @db.Decimal(10, 2) // Session price
  cancellationReason    String?
  cancelledAt           DateTime?
  confirmedAt           DateTime?
  creditGenerated       Boolean             @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic                  Clinic                    @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile     ProfessionalProfile       @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  patient                 Patient?                  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  recurrence              AppointmentRecurrence?    @relation(fields: [recurrenceId], references: [id], onDelete: SetNull)
  group                   TherapyGroup?             @relation(fields: [groupId], references: [id], onDelete: SetNull)
  notifications           Notification[]
  additionalProfessionals AppointmentProfessional[]
  invoiceItems           InvoiceItem[]
  sessionCredits         SessionCredit[]

  @@index([clinicId])
  @@index([professionalProfileId])
  @@index([patientId])
  @@index([recurrenceId])
  @@index([groupId])
  @@index([scheduledAt])
  @@index([status])
  @@index([type])
  @@index([clinicId, type])
  @@index([clinicId, scheduledAt])
  @@index([professionalProfileId, scheduledAt])
  @@index([clinicId, status])
  @@index([professionalProfileId, status, scheduledAt])
  @@index([groupId, scheduledAt])
}

/// Defines a recurring appointment pattern
model AppointmentRecurrence {
  id                    String               @id @default(cuid())
  clinicId              String
  professionalProfileId String
  patientId             String?
  type                  AppointmentType      @default(CONSULTA)
  title                 String?
  modality              AppointmentModality?
  dayOfWeek             Int // 0 = Sunday, 6 = Saturday
  startTime             String // HH:mm format
  endTime               String // HH:mm format
  duration              Int // in minutes
  recurrenceType        RecurrenceType
  recurrenceEndType     RecurrenceEndType
  startDate             DateTime             @db.Date
  endDate               DateTime?            @db.Date // null = indefinite (used when endType is BY_DATE)
  occurrences           Int? // Number of occurrences (used when endType is BY_OCCURRENCES)
  exceptions            String[]             @default([]) // Dates (YYYY-MM-DD) to skip in the recurrence
  lastGeneratedDate     DateTime?            @db.Date // Last date appointments were generated for INDEFINITE recurrences
  isActive              Boolean              @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic                  Clinic                   @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile     ProfessionalProfile      @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  patient                 Patient?                 @relation(fields: [patientId], references: [id], onDelete: Cascade)
  appointments            Appointment[]
  additionalProfessionals RecurrenceProfessional[]

  @@index([clinicId])
  @@index([professionalProfileId])
  @@index([patientId])
  @@index([isActive])
}

/// Notification records (email, SMS, WhatsApp)
model Notification {
  id            String              @id @default(cuid())
  clinicId      String
  patientId     String?
  appointmentId String?
  type          NotificationType
  channel       NotificationChannel
  status        NotificationStatus  @default(PENDING)
  recipient     String // email or phone number
  subject       String?
  content       String
  attempts      Int                 @default(0)
  maxAttempts   Int                 @default(3)
  nextRetryAt   DateTime?
  sentAt        DateTime?
  deliveredAt   DateTime?
  failedAt      DateTime?
  failureReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic      Clinic       @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  patient     Patient?     @relation(fields: [patientId], references: [id], onDelete: SetNull)
  appointment Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)

  @@index([clinicId])
  @@index([patientId])
  @@index([appointmentId])
  @@index([type])
  @@index([status])
  @@index([sentAt])
  @@index([nextRetryAt])
  @@index([clinicId, type])
  @@index([status, nextRetryAt])
}

/// Audit log for tracking important actions
model AuditLog {
  id         String   @id @default(cuid())
  clinicId   String
  userId     String?
  action     String
  entityType String // "Appointment", "Patient", etc.
  entityId   String
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?

  createdAt DateTime @default(now())

  // Relations
  clinic Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([clinicId])
  @@index([userId])
  @@index([entityType, entityId])
  @@index([action])
  @@index([createdAt])
  @@index([clinicId, createdAt])
}

/// Configurable notification templates per clinic
model NotificationTemplate {
  id        String              @id @default(cuid())
  clinicId  String
  type      NotificationType
  channel   NotificationChannel
  name      String              // Display name for the template
  subject   String?             // Email subject (only for EMAIL channel)
  content   String              // Template content with {{variables}}
  isActive  Boolean             @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Unique constraint: one template per type+channel per clinic
  @@unique([clinicId, type, channel])
  @@index([clinicId])
  @@index([type])
  @@index([channel])
  @@index([isActive])
}

/// Per-user feature permission overrides (if no row exists, role default applies)
model UserPermission {
  id        String        @id @default(cuid())
  userId    String
  clinicId  String
  feature   String        // e.g. "agenda_own", "patients", "users"
  access    FeatureAccess

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinic Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@unique([userId, feature])
  @@index([clinicId])
  @@index([userId])
}

// ============================================================================
// GROUP THERAPY MODELS
// ============================================================================

/// Defines a therapy group with a recurring schedule
model TherapyGroup {
  id                    String         @id @default(cuid())
  clinicId              String
  professionalProfileId String
  name                  String         // e.g., "Thursday Anxiety Group"
  dayOfWeek             Int            // 0-6 (Sunday-Saturday)
  startTime             String         // e.g., "14:00"
  duration              Int            @default(90) // in minutes
  recurrenceType        RecurrenceType @default(WEEKLY)
  isActive              Boolean        @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic                  Clinic                      @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile     ProfessionalProfile         @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  memberships             GroupMembership[]
  appointments            Appointment[]
  additionalProfessionals TherapyGroupProfessional[]

  @@index([clinicId])
  @@index([professionalProfileId])
  @@index([clinicId, isActive])
}

/// Tracks patient membership in a therapy group with temporal boundaries
model GroupMembership {
  id        String    @id @default(cuid())
  clinicId  String    // Denormalized for tenant isolation queries
  groupId   String
  patientId String
  joinDate  DateTime  @db.Date
  leaveDate DateTime? @db.Date // null = active member

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic  Clinic       @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  group   TherapyGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  patient Patient      @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@unique([groupId, patientId, joinDate])
  @@index([clinicId])
  @@index([groupId])
  @@index([patientId])
}

// ============================================================================
// MULTI-PROFESSIONAL JOIN TABLES
// ============================================================================

/// Links additional professionals to an appointment (beyond the primary owner)
model AppointmentProfessional {
  id                    String @id @default(cuid())
  appointmentId         String
  professionalProfileId String

  appointment         Appointment         @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile @relation("AppointmentParticipations", fields: [professionalProfileId], references: [id], onDelete: Cascade)

  @@unique([appointmentId, professionalProfileId])
  @@index([professionalProfileId])
  @@index([appointmentId])
}

/// Links additional professionals to a therapy group (co-leaders)
model TherapyGroupProfessional {
  id                    String @id @default(cuid())
  groupId               String
  professionalProfileId String

  group               TherapyGroup        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile @relation("GroupParticipations", fields: [professionalProfileId], references: [id], onDelete: Cascade)

  @@unique([groupId, professionalProfileId])
  @@index([professionalProfileId])
  @@index([groupId])
}

/// Links additional professionals to a recurrence pattern
model RecurrenceProfessional {
  id                    String @id @default(cuid())
  recurrenceId          String
  professionalProfileId String

  recurrence          AppointmentRecurrence @relation(fields: [recurrenceId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile   @relation("RecurrenceParticipations", fields: [professionalProfileId], references: [id], onDelete: Cascade)

  @@unique([recurrenceId, professionalProfileId])
  @@index([professionalProfileId])
  @@index([recurrenceId])
}

// ============================================================================
// FINANCIAL MODELS
// ============================================================================

/// Monthly invoice for a patient
model Invoice {
  id                    String        @id @default(cuid())
  clinicId              String
  professionalProfileId String
  patientId             String
  referenceMonth        Int
  referenceYear         Int
  status                InvoiceStatus @default(PENDENTE)
  totalSessions         Int
  creditsApplied        Int
  extrasAdded           Int
  totalAmount           Decimal       @db.Decimal(10, 2)
  dueDate               DateTime      @db.Date
  paidAt                DateTime?
  notes                 String?
  showAppointmentDays   Boolean       @default(false)
  messageBody           String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic              Clinic              @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  patient             Patient             @relation(fields: [patientId], references: [id], onDelete: Cascade)
  items               InvoiceItem[]
  consumedCredits     SessionCredit[]

  @@unique([professionalProfileId, patientId, referenceMonth, referenceYear])
  @@index([clinicId])
  @@index([professionalProfileId])
  @@index([patientId])
  @@index([status])
  @@index([clinicId, referenceYear, referenceMonth])
  @@index([professionalProfileId, referenceYear, referenceMonth])
}

/// Line item on an invoice
model InvoiceItem {
  id            String          @id @default(cuid())
  invoiceId     String
  appointmentId String?
  type          InvoiceItemType
  description   String
  quantity      Int             @default(1)
  unitPrice     Decimal         @db.Decimal(10, 2)
  total         Decimal         @db.Decimal(10, 2)

  createdAt DateTime @default(now())

  invoice     Invoice      @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  appointment Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)

  @@index([invoiceId])
  @@index([appointmentId])
}

/// Session credit from a cancelled appointment (CANCELADO_ACORDADO)
model SessionCredit {
  id                    String    @id @default(cuid())
  clinicId              String
  professionalProfileId String
  patientId             String
  originAppointmentId   String
  reason                String
  consumedByInvoiceId   String?
  consumedAt            DateTime?

  createdAt DateTime @default(now())

  clinic              Clinic              @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  professionalProfile ProfessionalProfile @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)
  patient             Patient             @relation(fields: [patientId], references: [id], onDelete: Cascade)
  originAppointment   Appointment         @relation(fields: [originAppointmentId], references: [id], onDelete: Cascade)
  consumedByInvoice   Invoice?            @relation(fields: [consumedByInvoiceId], references: [id], onDelete: SetNull)

  @@index([clinicId])
  @@index([professionalProfileId])
  @@index([patientId])
  @@index([consumedByInvoiceId])
  @@index([professionalProfileId, patientId, consumedByInvoiceId])
}
